% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_splits_rand_refine.R
\name{make_splits_rand_refine}
\alias{make_splits_rand_refine}
\title{Create a randomised data split.}
\usage{
make_splits_rand_refine(C, delta, X0 = NULL, w = c(2/3, 1/3), maxiter = 100)
}
\arguments{
\item{C}{matrix of class counts per group. Commonly calculated using
[consolidate_class_counts()]. Each position \eqn{c_{ij}} contains
the number of examples of the j-th Class contained in the i-th group.}

\item{delta}{vector of desired split proportions (must add up to one). It
is useful (but not mandatory) to use a vector delta that is sorted
in decreasing order, to prevent later confusion.}

\item{X0}{Initial (partial) allocation. Must be a binary numerical matrix
containing only zeroes and ones. Must have `nrow(C)` columns and `length(delta)`
rows. Each position \eqn{x_{ki}}
indicates the allocation (or not) of the i-th group to the k-th split.
Each group can only be allocated to (at most) one split (i.e.,
`colSums(X0)` \eqn{\leq 1}). Allocations provided in X0 are maintained in the
final solution returned.}

\item{w}{vector of weights for function aggregation. Must be of
length 2 and add to 1. All weights must be non-negative. `w[1]` represents the
relative importance of the split sizes and `w[2]` that of maintaining a
generally similar class balance in the splits.}

\item{maxiter}{integer; maximum number or refinement iterations.}
}
\value{
Matrix of binary allocation variables. Each position \eqn{x_{ki}}
indicates the allocation or not of the i-th group to the k-th split.
**NOTE**: The allocation matrix is always returned with splits in decreasing
order of size.
}
\description{
Generates a randomised allocation matrix that attempts to fulfill the
objectives of (i) adherence to the desired split proportions, and (ii)
homogeneous class balance across splits.
}
\examples{

library(moses)

\dontrun{
fpath1 <- system.file("diamond", "bfv_proteins.fa", package="moses")
fpath2 <- system.file("diamond", "bfv_peptides.rds", package="moses")

# Calculate clusters using sequence data
mycl <- extract_clusters_cdhit(seqfile = fpath1, diss_threshold = 0.2)

# Load data frame with classes
df <- readRDS(fpath2)

# Consolidate class counts
C <- consolidate_class_counts(mycl$clusters, df)

# Desired allocation proportions (train-validation-test)
delta <- c(.6, .2, .2)

X <- make_splits_rand_refine(C, delta)

# Check allocation:
M <- X \%*\% C

data.frame(Desired.prop = sort(delta, decreasing = TRUE),
           Actual.prop  = rowSums(M) / sum(M),
           Groups.per.split = rowSums(X))

# Balance of data in each split
Dbal <- cbind(data.frame(Overall = colSums(C) / sum(C)),
              apply(M, 1, function(z) z/sum(z)))
names(Dbal)[-1] <- paste0("Split.", names(Dbal)[-1])
Dbal

# Desired allocation proportions (5-fold CV folds + test)
delta <- c(rep(.16, 5), .2)
X <- make_splits_rand_refine(C, delta, w = c(.8, .2))
}
}
